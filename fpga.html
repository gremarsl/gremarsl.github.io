<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0">
    <meta name="description" content="Development of a Runtime Measurement System">
    <meta name="author" content="gremarsl">
    <title>FPGA Runtime Measurement System Development</title>
    <link rel="stylesheet" href="style.css">
    <script type="module" src="https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs" defer></script>
</head>

<body>
    <header>
        <nav class="navmenu">
            <div class="navlink">
                <a href="index.html">Home</a>
                <a href="housing.html">Housing Calculator</a>
                <a href="inflation.html">Inflation Calculator</a>
                <a href="tax.html">Bruttoverdienst-Analyse</a>
                <a href="social.html">Social Security Contributions</a>
                <a href="fpga.html" class="current">Development of a Runtime Measurement System</a>
            </div>
        </nav>
    </header>

    <main>
        <article>
            <h1>Development of a Runtime Measurement System</h1>

            <!-- Table of Contents / Agenda Overview -->
            <section id="agenda" class="agenda-section">
                <h2>Chapter Overview</h2>
                <nav class="table-of-contents">
                    <ul>
                        <li><a href="#introduction">Introduction</a></li>
                        <li><a href="#use-case">Our Use Case - The Development Process</a></li>
                        <li><a href="#development-workflow">Our Use Case - The Development Workflow</a></li>
                        <li><a href="#problem-statement">The Problem Statement</a></li>
                        <li><a href="#idea">The Idea / The Improvement Statement</a></li>
                        <li><a href="#solution-space">Solution Space</a>
                            <ul>
                                <li><a href="#highlevel-design">Highlevel System Design</a></li>
                                <li><a href="#fpga-design">FPGA Focused Design</a></li>
                            </ul>
                        </li>
                        <li><a href="#toolchain-simulation">Toolchain for Simulation and Verification</a></li>
                        <li><a href="#toolchain-hardware">Toolchain for Hardware Flashing</a></li>
                        <li><a href="#roadmap">Development Roadmap & Future Enhancements</a></li>
                        <li><a href="#resolution">System Resolution</a></li>
                        <li><a href="#contact">Get in Touch</a></li>
                    </ul>
                </nav>
            </section>
            
            <!-- Introduction Section -->
            <section id="introduction">
                <h2>Introduction</h2>
                <p>I am developing a system designed to accurately measure and analyze runtime of various software or
                    hardware processes. The idea for this system arose from the need for precise timing and measurement solutions
                    within the context of embedded systems development.</p>
                <p>Let's examine a practical use case.</p>
            </section>

            <!-- Use Case Section -->
            <section id="use-case">
                <h2>Our Use Case - The Development Process</h2>
                <p>Our developed system (System A) handles two distinct events: Event A (entering) and Event B
                    (exiting).</p>
                <div class="svg-container">
                    <object type="text/html" data="svgs/systema.html" width="1000" height="200"
                        aria-label="System A diagram"></object>
                </div>

                <p>These events are represented by rising and falling edges on a digital signal line. The time interval
                    between these two events (t<sub>B</sub>-t<sub>A</sub>) represents the runtime of the process we want to
                    measure.</p>

                <div class="svg-container">
                    <object type="text/html" data="svgs/systema_base.html" width="1000" height="350"></object>
                </div>
                
                <p>Since our system must fulfill specific timing requirements, t<sub>B</sub>-t<sub>A</sub> must be
                    within the maximum allowed time constraints. Therefore we add the green line Δt<sub>max_allowed</sub>.</p>
                
                <div class="svg-container">
                    <object type="text/html" data="svgs/systema_base_tmax.html" width="1000" height="300"></object>
                </div>

                <p>When we look into our system, the system consists of two modules. Module 1 is responsible for
                    processing input data, while Module 2 handles output data. Our System A fulfills the requirement. Therefore we
                    release this system with version 1.0.</p>

                <div class="svg-container">
                    <object type="text/html" data="svgs/systema_module.html" width="1000" height="300"></object>
                </div>

                <p>Let's assume a fictitious customer requests a new feature for our system. Leading to a third module
                    being added to the system. After a few months the Module 3 is almost completed and integrated into the system.
                    Integration tests can finally be performed to ensure that the new module works correctly with the existing
                    modules.</p>
                
                <div class="svg-container">
                    <object type="text/html" data="svgs/systema_module3.html" width="900" height="300"></object>
                </div>

                <p>After integrating Module 3, we observe that the runtime (t<sub>B</sub>-t<sub>A</sub>) has increased
                    and now exceeds the maximum allowed time constraint (Δt<sub>max_allowed</sub>). This indicates that the addition of Module 3 has
                    negatively impacted the system's performance, leading to a violation of the timing requirements.</p>

                <div class="svg-container">
                    <object type="text/html" data="svgs/systema_module_tmax.html" width="900" height="300"></object>
                </div>

                <h3>Conclusion - The Development Process</h3>
                <p>Now we got a better understanding of the engineering perspective. But to really understand the full
                    problem, we have to have a look into the development workflow we used above.</p>
            </section>

            <!-- Development Workflow Section -->
            <section id="development-workflow">
                <h2>Our Use Case - The Development Workflow</h2>
                <div class="svg-container">
                    <object type="text/html" data="svgs/workflow_before.html" width="700" height="300"></object>
                </div>

                <h3>Summary</h3>
                <p>This workflow clearly demonstrates the need for a more structured approach to runtime monitoring. With the current development process and workflow, we are not able to effectively monitor and manage runtime performance during our processes and workflows. One-shot measurements are not sufficient to capture the dynamic behavior of the system over time.</p>
                <p>The summary was easy, I guess. Before we dive into the solution space, let's explore the problem more deeply.</p>
                
            </section>
            
            <!-- Problem Statement Section -->
            <section id="problem-statement">
                <h2>The Problem Statement</h2>
                <p>With the described use case above, we've realized we have different problems that need to be addressed.</p>

                <h3>Workflow related challenges</h3>
                <p>With our current development process to develop our System A, we face several challenges:</p>
                <ul>
                    <li>Lack of early detection for performance issues since we rely on prerelease runtime analysis.</li>
                    <li>Inability to track performance trends during the development phase over time</li>
                    <li>One-shot manual measurements are time-consuming and error-prone</li>
                </ul>
                <p>What we need is:</p>
                <ul>
                    <li>Detect timing violations immediately, not just before release</li>
                    <li>Prevent costly late-stage fixes</li>
                    <li>Track performance trends throughout development</li>
                    <li>Rather than discovering issues at release time, systematic automated measurements during each development phase allow us to maintain control over system timing constraints.</li>
                    <li>Replace our one-shot measurements directly before release as they provide only one data point, but do not offer insights into performance trends over time or under varying conditions.</li>
                </ul>

                <h3>Measurement accuracy related challenges</h3>
                <p>Software-based measurements are popular and easy to realize. However, they change the system under test since you add measurement code. Accuracy is limited and dependent on the speed the embedded system is clocked at and the overhead introduced by the software-defined runtime measurement. This results in massively changing the time behavior of the system. To reduce the intrusiveness, changing the measurement methodology to use external hardware can be useful.</p>

                </section>
                
                <!-- The Idea / Improvement Statement Section -->
                <section id="idea">
                    <h2>The Idea / The Improvement Statement</h2>
                    <p>Based on the problems identified above, the solution is clear: we need an automated, non-intrusive, 
                    and easy-to-integrate runtime measurement system that can be embedded directly into the development 
                    workflow.</p>
                    
                    <p>Instead of relying on software-based measurements that alter system behavior, we propose using 
                    an FPGA-based external measurement system that:</p>
                    
                    <ul>
                        <li>Monitors the system's input and output signals with a minimum need for modifying the system under test</li>
                        <li>Provides high-resolution timing measurements using an internal or external oscillator</li>
                        <li>Requires minimal setup and wiring</li>
                        <li>Can be integrated into existing development workflows</li>
                        <li>Generates performance reports and trend analysis</li>
                    </ul>
                    
                    <p>This approach eliminates the overhead of software-based measurements while providing developers 
                    with continuous visibility into system performance. By catching timing violations early and tracking 
                    performance trends throughout development, we can prevent costly late-stage fixes and maintain strict 
                    control over timing constraints.</p>
                    
                    <p>The FPGA acts as an independent observer, passively measuring the time between Event A (entering) 
                    and Event B (exiting) without interfering with the system's actual operation. This provides accurate, 
                    reliable measurements that reflect the true system behavior.</p>
                </section>
                
                <!-- Solution Space Section -->
                <section id="solution-space">
                    <h2>Let's enter the solution space.</h2>
                    <h3>Proposed Development Workflow with Runtime Analysis (During Development)</h3>
                    
                    <div class="svg-container">
                        <object type="text/html" data="svgs/workflow_proposed.html" width="700" height="300"></object>
                    </div>
    
                    <p>This proposal seems obvious. You might think: "I have thought of that just by reading this in 5
                        minutes." However, the challenge lies in implementing and maintaining such a systematic approach
                        throughout development. Since:</p>
    
                    <ul>
                        <li>We want to prevent additional effort and guidance for developers for timing analysis. It must be
                            optional instead of obligatory. We trust the developer to decide by himself when to perform
                            timing analysis.</li>
                        <li>We want to prevent buying resource intensive tracing tools and infrastructure even though there
                            is no need to look into each of our modules internal behaviour. We just want to measure the
                            overall system performance t<sub>B</sub>-t<sub>A</sub> at this validation stage. Everything else
                            is overkill.</li>
                        <li>We want to prevent time consuming setup, wiring. If it is hard to integrate, it will not be
                            used.</li>
                    </ul>

                <!-- Highlevel System Design Subsection -->
                <section id="highlevel-design">
                    <h3>Highlevel System Design Diagram</h3>
                    <pre class="mermaid">
    graph TD
    I(Measurement Input Signal) --- F(FPGA)
    O(Oscillator) --- F(FPGA)
    F(FPGA) ---|UART| S(Smaller CPU)
    S --- |USB/ ETH| L(Larger CPU)

    style F fill:#FFFFED,stroke:#FCE992
    style I fill:none,stroke:#228B22
    linkStyle 0 stroke:#228B22
                    </pre>
                </section>

                <!-- FPGA Focused Design Subsection -->
                <section id="fpga-design">
                    <h3>FPGA Focused System Design Diagram</h3>
                    <pre class="mermaid">
    graph TD
    I(Measurement Input Signal) --- F
    Hz(1Hz Debug Pin) --- F
    D(Debug Pin) --- F
    O(optional external Oscillator) --- F
    
    subgraph F[FPGA]
        direction TB
        subgraph Left[" "]
            direction TB
            RE[Rising & Falling Edge Detector] --- CC
            CC[ Clock Counter]
            CC --- DSM[Calulation & Measurement Data Storage Module]
            DSM --- U
            OO(Onboard Oscillator) --- CC
            RE --- DSM
        end
        subgraph U[UART]
            direction TB
            URX[UART RX]
            UTX[UART TX]
        end
        Left ~~~ U
    end
    
    F ---|UART| S(Smaller CPU - intermediate storage)
    S ---|USB/ ETH| L(Larger CPU - visualization)
    
    style I fill:none,stroke:#228B22
    style Hz fill:none,stroke:#000000
    style D fill:none,stroke:#000000
    style Left fill:none,stroke:none
                    </pre>
                </section>
            </section>

            <!-- Toolchain Simulation Section -->
            <section id="toolchain-simulation">
                <h2>Toolchain for Simulation and Verification of Verilog Design</h2>
                
                <h3>VVP</h3>
                <p>vvp is the runtime engine that executes the default compiled form generated by Icarus Verilog.</p>

                <h3>GTKWave</h3>
                <p>Programm to view waveforms. Used after simulation.</p>
                <p>Configuration file: .gtkw</p>

                <pre class="mermaid">
    graph LR
        d(Design Implementation in Verilog) -->|.verilog / .v| IV(iverilog compiler)
        IV---> |.vvp| VVP(vvp)
        VVP---> |.vcd| G(Gtkwave)
        G ---> d
                </pre>
            </section>

            <!-- Toolchain Hardware Section -->
            <section id="toolchain-hardware">
                <h2>Toolchain for Flashing and Verification on Real Hardware</h2>
                
                <pre class="mermaid">
    graph LR
        .verilog --> YS(Yosys Script)
        YS-->|.ys| Y(Yosys)
        .pcf --> N(Nextpnr)
        Y --> |.json, .blif,synth.v| N(Nextpnr)
        N --> |.asc| I(icepack)
        I --> |.bin| BF2(bin2uf2 Conversion)
        BF2 --> |.uf2| FPGA(Flash to FPGA)
        style .verilog fill:none,stroke:none
        style .pcf fill:none,stroke:none
                </pre>
            </section>

            <!-- Development Roadmap Section -->
            <section id="roadmap">
                <h2>Development Roadmap & Future Enhancements</h2>

                <ul>
                    <li>Add / Verify option to integrate an external oscillator.</li>
                    <li>Evaluate memory storage size on the FPGA side. Develop option to use shared RAM?</li>
                    <li>Add option to configure the UART data rate. Currently only 9600 bits/second.</li>
                    <li>Add available measurement points (pins).</li>
                    <li>Stabilize tx and rx of UART communication from and to FPGA</li>
                    <li>Implement firmware for raspberry pi (smaller CPU) to request & receive the data and publish is
                        via ETH</li>
                    <li>Data visualization implementation on larger CPU</li>
                    <li>Stable protocol definition</li>
                </ul>
            </section>

            <!-- System Resolution Section -->
            <section id="resolution">
                <h2>System Resolution</h2>

                <p>Resolution and accuracy depends on the clocking speed of the system. What is our accuracy if we use
                    an oscillator with frequency f?</p>

                <div class="table-container">
                    <table class="measurement-table">
                        <thead>
                            <tr>
                                <th>Frequency (f)</th>
                                <th>Period (T)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>12 MHz</td>
                                <td>83.33 ns</td>
                            </tr>
                            <tr>
                                <td>50 MHz</td>
                                <td>20 ns</td>
                            </tr>
                            <tr>
                                <td>100 MHz</td>
                                <td>10 ns</td>
                            </tr>
                            <tr>
                                <td>500 MHz</td>
                                <td>2 ns</td>
                            </tr>
                            <tr>
                                <td>1 GHz</td>
                                <td>1 ns</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <p>This means with a clocking oscillator of 100 MHz we can measure time events with a resolution of 10 ns.</p>
                <ul>
                    <li><strong>Resolution:</strong> the smallest time increment you can distinguish (determined by clock period)</li>
                    <li><strong>Accuracy:</strong> how close your measurement is to the true value (affected by clock stability, jitter,
                        calibration, etc.)</li>
                </ul>
            </section>
        </article>

        <!-- Contact Section -->
        <section id="contact" class="contact-section">
            <h2>Get in Touch</h2>
            <p>Interested in how this runtime measurement system could optimize your work? Let's discuss your specific
                use case!</p>
            <a href="mailto:sophia.wegers@gmail.com" class="contact-button">Contact Me</a>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 gremarsl. All rights reserved.</p>
    </footer>

    <!-- Hamburger menu script -->
    <script>
        const hamburger = document.querySelector('.hamburger');
        const navMenu = document.querySelector('.navlink');

        if (hamburger) {
            hamburger.addEventListener('click', () => {
                hamburger.classList.toggle('active');
                navMenu.classList.toggle('active');
            });

            document.querySelectorAll('.navlink a').forEach(link => {
                link.addEventListener('click', () => {
                    hamburger.classList.remove('active');
                    navMenu.classList.remove('active');
                });
            });
        }
    </script>
</body>

</html>